name: Deploy Infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Entorno a desplegar'
        required: true
        type: choice
        options:
          - dev
          - stage
          - prod

env:
  TF_VERSION: '1.6.0'

jobs:
  terraform-apply:
    name: Deploy ${{ matrix.environment }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        environment: ${{ fromJSON(format('["{0}"]', github.event.inputs.environment)) }}
    environment:
      name: ${{ matrix.environment }}
    
    steps:

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Validate Secrets
        run: |
          MISSING_SECRETS=()
          
          if [ -z "${{ secrets.AZURE_STATE_RESOURCE_GROUP }}" ]; then MISSING_SECRETS+=("AZURE_STATE_RESOURCE_GROUP"); fi
          if [ -z "${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" ]; then MISSING_SECRETS+=("AZURE_STATE_STORAGE_ACCOUNT"); fi
          if [ -z "${{ secrets.AZURE_STATE_CONTAINER }}" ]; then MISSING_SECRETS+=("AZURE_STATE_CONTAINER"); fi
          if [ -z "${{ secrets.AZURE_CLIENT_ID }}" ]; then MISSING_SECRETS+=("AZURE_CLIENT_ID"); fi
          if [ -z "${{ secrets.AZURE_CLIENT_SECRET }}" ]; then MISSING_SECRETS+=("AZURE_CLIENT_SECRET"); fi
          if [ -z "${{ secrets.AZURE_SUBSCRIPTION_ID }}" ]; then MISSING_SECRETS+=("AZURE_SUBSCRIPTION_ID"); fi
          if [ -z "${{ secrets.AZURE_TENANT_ID }}" ]; then MISSING_SECRETS+=("AZURE_TENANT_ID"); fi
          if [ -z "${{ secrets.RESOURCE_PREFIX }}" ]; then MISSING_SECRETS+=("RESOURCE_PREFIX"); fi
          if [ -z "${{ secrets.AZURE_LOCATION }}" ]; then MISSING_SECRETS+=("AZURE_LOCATION"); fi
          if [ -z "${{ secrets.CLUSTER_NAME_BASE }}" ]; then MISSING_SECRETS+=("CLUSTER_NAME_BASE"); fi
          
          # Validar secrets especÃ­ficos del ambiente
          if [ "${{ matrix.environment }}" = "dev" ]; then
            if [ -z "${{ secrets.AZURE_RESOURCE_GROUP_DEV }}" ]; then MISSING_SECRETS+=("AZURE_RESOURCE_GROUP_DEV"); fi
            if [ -z "${{ secrets.AKS_CLUSTER_NAME_DEV }}" ]; then MISSING_SECRETS+=("AKS_CLUSTER_NAME_DEV"); fi
          elif [ "${{ matrix.environment }}" = "stage" ]; then
            if [ -z "${{ secrets.AZURE_RESOURCE_GROUP_STAGE }}" ]; then MISSING_SECRETS+=("AZURE_RESOURCE_GROUP_STAGE"); fi
            if [ -z "${{ secrets.AKS_CLUSTER_NAME_STAGE }}" ]; then MISSING_SECRETS+=("AKS_CLUSTER_NAME_STAGE"); fi
          elif [ "${{ matrix.environment }}" = "prod" ]; then
            if [ -z "${{ secrets.AZURE_RESOURCE_GROUP_PROD }}" ]; then MISSING_SECRETS+=("AZURE_RESOURCE_GROUP_PROD"); fi
            if [ -z "${{ secrets.AKS_CLUSTER_NAME_PROD }}" ]; then MISSING_SECRETS+=("AKS_CLUSTER_NAME_PROD"); fi
          fi
          
          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "âŒ Error: Missing required secrets:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            exit 1
          fi
          
          echo "âœ… All required secrets are configured"

      - name: Ensure Storage Container Exists
        run: |
          echo "ðŸ” Verificando si el contenedor de almacenamiento existe..."
          CONTAINER_EXISTS=$(az storage container exists \
            --account-name "${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" \
            --name "${{ secrets.AZURE_STATE_CONTAINER }}" \
            --auth-mode login \
            --query exists -o tsv 2>/dev/null || echo "false")
          
          if [ "$CONTAINER_EXISTS" = "false" ]; then
            echo "ðŸ“¦ Contenedor no existe, creÃ¡ndolo..."
            az storage container create \
              --account-name "${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" \
              --name "${{ secrets.AZURE_STATE_CONTAINER }}" \
              --auth-mode login \
              --public-access off || echo "âš ï¸ Error al crear el contenedor (puede que ya exista)"
            echo "âœ… Contenedor creado o verificado"
          else
            echo "âœ… El contenedor ya existe"
          fi
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        continue-on-error: true

      - name: Terraform Init
        id: init
        run: |
          echo "ðŸ”§ Inicializando Terraform con backend remoto..."
          terraform init \
            -backend-config="resource_group_name=${{ secrets.AZURE_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ secrets.AZURE_STATE_CONTAINER }}" \
            -backend-config="key=${{ matrix.environment }}/terraform.tfstate" \
            -reconfigure
          echo "âœ… Terraform inicializado"
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Check State
        run: |
          if terraform state list 2>/dev/null | grep -q .; then
            echo "âœ… Estado encontrado con recursos existentes"
            terraform state list | head -20
          else
            echo "â„¹ï¸ Estado vacÃ­o o no existe (primera ejecuciÃ³n)"
          fi
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        continue-on-error: true

      - name: Setup Azure CLI
        run: |
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
          az login --service-principal \
            -u "$ARM_CLIENT_ID" \
            -p "$ARM_CLIENT_SECRET" \
            --tenant "$ARM_TENANT_ID" \
            --output none
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Clean State (Remove Orphaned Resources)
        run: |
          echo "ðŸ§¹ Limpiando recursos huÃ©rfanos del estado de Terraform..."
          
          ORPHANED_RESOURCES=(
            "module.k8s_configmaps"
            "azurerm_resource_group.keyvault"
            "module.keyvault"
          )
          
          for resource in "${ORPHANED_RESOURCES[@]}"; do
            if terraform state list 2>/dev/null | grep -q "$resource"; then
              echo "âš ï¸ Encontrado $resource en el estado - eliminando..."
              terraform state list | grep "$resource" | while read res; do
                echo "Eliminando: $res"
                terraform state rm "$res" 2>&1 || echo "No se pudo eliminar $res"
              done
            fi
          done
          
          echo "âœ… Limpieza del estado completada"
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        continue-on-error: true

      - name: Terraform Plan
        id: plan
        run: |
          echo "ðŸ“‹ Iniciando Terraform Plan para ${{ matrix.environment }}..."
          rm -f tfplan plan_output.txt
          
          set +e
          terraform plan \
            -var-file=environments/${{ matrix.environment }}/terraform.tfvars \
            -var="resource_prefix=${{ secrets.RESOURCE_PREFIX }}" \
            -var="location=${{ secrets.AZURE_LOCATION }}" \
            -var="cluster_name=${{ secrets.CLUSTER_NAME_BASE }}" \
            -out=tfplan -detailed-exitcode 2>&1 | tee plan_output.txt
          PLAN_EXIT_CODE=${PIPESTATUS[0]}
          set -e
          
          echo "ðŸ“Š CÃ³digo de salida del plan: $PLAN_EXIT_CODE"
          
          # CÃ³digo 0 = sin cambios, 1 = error, 2 = cambios detectados
          if [ "$PLAN_EXIT_CODE" = "1" ]; then
            echo "âŒ Error durante la ejecuciÃ³n del plan"
            cat plan_output.txt
            
            if [ -f tfplan ]; then
              echo "âš ï¸ Plan file existe pero con error - eliminÃ¡ndolo"
              rm -f tfplan
            fi
            
            if grep -q "already exists" plan_output.txt; then
              echo "âš ï¸ Detectados recursos existentes que no estÃ¡n en el estado"
              echo "ðŸ”„ Intentando importar recursos existentes..."
              
              if [ "${{ matrix.environment }}" = "dev" ]; then
                RG_NAME="${{ secrets.AZURE_RESOURCE_GROUP_DEV }}"
              elif [ "${{ matrix.environment }}" = "stage" ]; then
                RG_NAME="${{ secrets.AZURE_RESOURCE_GROUP_STAGE }}"
              elif [ "${{ matrix.environment }}" = "prod" ]; then
                RG_NAME="${{ secrets.AZURE_RESOURCE_GROUP_PROD }}"
              fi
              
              if az group show --name "$RG_NAME" --query id -o tsv 2>/dev/null | grep -q .; then
                RG_ID="/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/$RG_NAME"
                echo "ðŸ“¥ Importando Resource Group: $RG_NAME"
                terraform import module.aks.azurerm_resource_group.main "$RG_ID" 2>&1 || echo "âš ï¸ Resource Group ya en estado o error al importar"
              fi
              
              echo "ðŸ”„ Re-ejecutando plan despuÃ©s de importar..."
              rm -f tfplan plan_output.txt
              set +e
              terraform plan \
                -var-file=environments/${{ matrix.environment }}/terraform.tfvars \
                -var="resource_prefix=${{ secrets.RESOURCE_PREFIX }}" \
                -var="location=${{ secrets.AZURE_LOCATION }}" \
                -var="cluster_name=${{ secrets.CLUSTER_NAME_BASE }}" \
                -out=tfplan -detailed-exitcode 2>&1 | tee plan_output.txt
              PLAN_EXIT_CODE=${PIPESTATUS[0]}
              set -e
              
              echo "ðŸ“Š CÃ³digo de salida del plan (despuÃ©s de importar): $PLAN_EXIT_CODE"
              
              if [ "$PLAN_EXIT_CODE" = "1" ]; then
                echo "âŒ Error: Plan fallÃ³ despuÃ©s de importar"
                cat plan_output.txt
                if [ -f tfplan ]; then
                  rm -f tfplan
                fi
                exit 1
              fi
            else
              echo "âŒ Error durante el plan (no relacionado con recursos existentes)"
              cat plan_output.txt
              exit 1
            fi
          fi
          
          # Validar que el plan se completÃ³ correctamente
          if [ "$PLAN_EXIT_CODE" = "2" ]; then
            echo "âœ… Plan generado exitosamente con cambios a aplicar"
            if [ ! -f tfplan ]; then
              echo "âŒ ERROR CRÃTICO: Plan exitoso pero no se generÃ³ el archivo tfplan"
              exit 1
            fi
            echo "âœ… Archivo tfplan creado correctamente"
          elif [ "$PLAN_EXIT_CODE" = "0" ]; then
            echo "â„¹ï¸ No hay cambios que aplicar"
            rm -f tfplan
          else
            echo "âŒ ERROR: CÃ³digo de salida inesperado del plan: $PLAN_EXIT_CODE"
            cat plan_output.txt
            exit 1
          fi
          
          echo "ðŸ“‹ Resumen del plan:"
          cat plan_output.txt | tail -20
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Force Unlock State (if locked)
        run: |
          echo "ðŸ”“ Verificando si el estado estÃ¡ bloqueado..."
          set +e
          terraform plan \
            -var-file=environments/${{ matrix.environment }}/terraform.tfvars \
            -var="resource_prefix=${{ secrets.RESOURCE_PREFIX }}" \
            -var="location=${{ secrets.AZURE_LOCATION }}" \
            -var="cluster_name=${{ secrets.CLUSTER_NAME_BASE }}" \
            -lock=false 2>&1 | tee unlock_check.txt
          set -e
          
          if grep -q "state blob is already locked" unlock_check.txt; then
            echo "âš ï¸ Estado bloqueado detectado, extrayendo Lock ID..."
            LOCK_ID=$(grep -oP 'ID:\s+\K[a-f0-9-]+' unlock_check.txt | head -1 || echo "")
            if [ -n "$LOCK_ID" ]; then
              echo "ðŸ”“ Liberando lock: $LOCK_ID"
              terraform force-unlock -force "$LOCK_ID" || echo "âš ï¸ No se pudo liberar el lock (puede que ya estÃ© liberado)"
            fi
          fi
          rm -f unlock_check.txt
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        continue-on-error: true

      - name: Terraform Apply
        run: |
          echo "ðŸ” Verificando que el plan se ejecutÃ³ correctamente..."
          
          if [ ! -f tfplan ]; then
            echo "âŒ ERROR: No se encontrÃ³ el archivo tfplan"
            echo "âš ï¸ El paso de Terraform Plan debe ejecutarse y generar un plan vÃ¡lido antes de aplicar"
            echo "ðŸ“‹ Revisa los logs del paso 'Terraform Plan' para ver quÃ© saliÃ³ mal"
            exit 1
          fi
          
          echo "âœ… Archivo tfplan encontrado"
          echo "ðŸš€ Aplicando cambios de Terraform..."
          set +e
          terraform apply -auto-approve tfplan 2>&1 | tee apply_output.txt
          APPLY_EXIT_CODE=${PIPESTATUS[0]}
          set -e
          
          if [ "$APPLY_EXIT_CODE" -ne 0 ]; then
            if grep -q "state blob is already locked" apply_output.txt; then
              echo "âš ï¸ Estado aÃºn bloqueado, extrayendo Lock ID y liberando..."
              LOCK_ID=$(grep -oP 'ID:\s+\K[a-f0-9-]+' apply_output.txt | head -1 || echo "")
              if [ -n "$LOCK_ID" ]; then
                echo "ðŸ”“ Liberando lock: $LOCK_ID"
                terraform force-unlock -force "$LOCK_ID"
                echo "ðŸ”„ Reintentando apply..."
                terraform apply -auto-approve tfplan
              else
                echo "âŒ No se pudo extraer el Lock ID"
                cat apply_output.txt
                exit 1
              fi
            else
              echo "âŒ Error durante el apply"
              cat apply_output.txt
              exit $APPLY_EXIT_CODE
            fi
          else
            echo "âœ… Apply completado exitosamente"
          fi
          rm -f apply_output.txt
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Verify State Saved to Backend
        run: |
          echo "ðŸ” Verificando que el estado se guardÃ³ en Azure Storage..."
          STATE_KEY="${{ matrix.environment }}/terraform.tfstate"
          echo "ðŸ“ Ruta del estado: $STATE_KEY"
          
          # Verificar que el blob existe en el storage
          if az storage blob exists \
            --account-name "${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" \
            --container-name "${{ secrets.AZURE_STATE_CONTAINER }}" \
            --name "$STATE_KEY" \
            --auth-mode login \
            --query exists -o tsv 2>/dev/null | grep -q "true"; then
            echo "âœ… Estado verificado - se guardÃ³ en Azure Storage: ${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}/${{ secrets.AZURE_STATE_CONTAINER }}/$STATE_KEY"
            
            # Obtener informaciÃ³n del blob
            BLOB_INFO=$(az storage blob show \
              --account-name "${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" \
              --container-name "${{ secrets.AZURE_STATE_CONTAINER }}" \
              --name "$STATE_KEY" \
              --auth-mode login \
              --query "{size:properties.contentLength,lastModified:properties.lastModified}" -o json 2>/dev/null || echo "{}")
            
            if [ "$BLOB_INFO" != "{}" ]; then
              echo "ðŸ“Š InformaciÃ³n del estado:"
              echo "$BLOB_INFO" | jq -r '"TamaÃ±o: " + (.size | tostring) + " bytes, Ãšltima modificaciÃ³n: " + .lastModified'
            fi
          else
            echo "âš ï¸ No se pudo verificar el blob en Azure Storage (puede ser normal si es la primera ejecuciÃ³n)"
            echo "ðŸ“‹ Listando estados disponibles en el storage:"
            az storage blob list \
              --account-name "${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" \
              --container-name "${{ secrets.AZURE_STATE_CONTAINER }}" \
              --auth-mode login \
              --query "[].name" -o tsv 2>/dev/null | head -10 || echo "No se pudieron listar los blobs"
          fi
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        continue-on-error: true

      - name: Terraform Output
        id: terraform_output
        run: |
          terraform output -json > terraform_output.json
          cat terraform_output.json
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Parse Terraform Outputs
        id: parse_outputs
        run: |
          RESOURCE_GROUP=$(jq -r '.resource_group_name.value // empty' terraform_output.json)
          CLUSTER_NAME=$(jq -r '.cluster_name.value // empty' terraform_output.json)
          
          if [ -z "$RESOURCE_GROUP" ] || [ "$RESOURCE_GROUP" = "null" ]; then
            echo "âŒ Error: resource_group_name no encontrado en outputs"
            cat terraform_output.json
            exit 1
          fi
          
          if [ -z "$CLUSTER_NAME" ] || [ "$CLUSTER_NAME" = "null" ]; then
            echo "âŒ Error: cluster_name no encontrado en outputs"
            cat terraform_output.json
            exit 1
          fi
          
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "Resource Group: $RESOURCE_GROUP"
          echo "Cluster Name: $CLUSTER_NAME"
          
          if az group show --name "$RESOURCE_GROUP" --query id -o tsv 2>/dev/null | grep -q .; then
            echo "âœ… Resource Group encontrado en Azure"
          else
            echo "âŒ Error: Resource Group '$RESOURCE_GROUP' no existe en Azure"
            exit 1
          fi
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group "${{ steps.parse_outputs.outputs.resource_group }}" \
            --name "${{ steps.parse_outputs.outputs.cluster_name }}" \
            --overwrite-existing
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Create Spring ConfigMap in Kubernetes
        run: |
          echo "ðŸ“¦ Creando ConfigMap con variables de entorno para Spring Boot..."
          kubectl create configmap spring-env-config \
            --from-literal=SPRING_ZIPKIN_BASE_URL="http://zipkin:9411" \
            --from-literal=SPRING_CONFIG_IMPORT="http://cloud-config-service:9296" \
            --from-literal=EUREKA_CLIENT_SERVICEURL_DEFAULTZONE="http://service-discovery:8761/eureka" \
            --from-literal=SPRING_CLOUD_CONFIG_SERVER_GIT_URI="https://github.com/Ecommerce-Service-JDiaz/ecommerce-cloud-config-server" \
            --from-literal=SPRING_CLOUD_CONFIG_SERVER_GIT_DEFAULT_LABEL="main" \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "âœ… ConfigMap creado exitosamente"
        continue-on-error: true

      - name: Deployment Summary
        run: |
          echo "## âœ… Infraestructura ${{ matrix.environment }} Desplegada" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Entorno:** ${{ matrix.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Resource Group:** ${{ steps.parse_outputs.outputs.resource_group }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster Name:** ${{ steps.parse_outputs.outputs.cluster_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Estado guardado en:** \`${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}/${{ secrets.AZURE_STATE_CONTAINER }}/${{ matrix.environment }}/terraform.tfstate\`" >> $GITHUB_STEP_SUMMARY
          echo "**Ejecutado por:** @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Fecha:** $(date)" >> $GITHUB_STEP_SUMMARY
