name: Deploy Infrastructure

on:
  pull_request:
    branches:
      - main
    paths:
      - '**/*.tf'
      - '**/*.tfvars'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Entorno a desplegar (dejar vac√≠o para todos)'
        required: false
        type: choice
        options:
          - all
          - dev
          - stage
          - prod

env:
  TF_VERSION: '1.6.0'

jobs:
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        id: fmt
        run: terraform fmt -check
        continue-on-error: true

      - name: Terraform Init
        id: init
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.AZURE_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ secrets.AZURE_STATE_CONTAINER }}" \
            -backend-config="key=terraform.tfstate"
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Terraform Validate
        id: validate
        run: terraform validate -no-color

      - name: Terraform Plan
        id: plan
        run: |
          ENV=$(echo "${{ github.head_ref }}" | grep -oE '(dev|stage|prod)' || echo "dev")
          terraform plan -var-file=environments/$ENV/terraform.tfvars -no-color
        continue-on-error: true
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Comment PR
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        env:
          PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
            #### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
            #### Terraform Validation ü§ñ\`${{ steps.validate.outcome }}\`
            #### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`
            
            <details><summary>Show Plan</summary>
            
            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`
            
            </details>
            
            *Pusheado por: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  terraform-apply:
    name: Deploy ${{ matrix.environment }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - environment: dev
            resource_group_secret: AZURE_RESOURCE_GROUP_DEV
            cluster_name_secret: AKS_CLUSTER_NAME_DEV
          - environment: stage
            resource_group_secret: AZURE_RESOURCE_GROUP_STAGE
            cluster_name_secret: AKS_CLUSTER_NAME_STAGE
          - environment: prod
            resource_group_secret: AZURE_RESOURCE_GROUP_PROD
            cluster_name_secret: AKS_CLUSTER_NAME_PROD
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      github.event_name == 'workflow_dispatch'
    environment:
      name: ${{ matrix.environment }}
    
    steps:
      - name: Check Environment Filter
        id: env_check
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SELECTED_ENV="${{ github.event.inputs.environment }}"
            CURRENT_ENV="${{ matrix.environment }}"
            
            echo "üìã Ambiente seleccionado: $SELECTED_ENV"
            echo "üìã Ambiente del job: $CURRENT_ENV"
            
            if [ "$SELECTED_ENV" != "all" ] && [ "$SELECTED_ENV" != "$CURRENT_ENV" ]; then
              echo "‚è≠Ô∏è Saltando ambiente $CURRENT_ENV (solo se despliega $SELECTED_ENV)"
              echo "should_skip=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          echo "‚úÖ Desplegando ambiente ${{ matrix.environment }}"
          echo "should_skip=false" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Checkout code
        if: steps.env_check.outputs.should_skip != 'true'
        uses: actions/checkout@v4

      - name: Setup Terraform
        if: steps.env_check.outputs.should_skip != 'true'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Validate Secrets
        if: steps.env_check.outputs.should_skip != 'true'
        run: |
          MISSING_SECRETS=()
          
          if [ -z "${{ secrets.AZURE_STATE_RESOURCE_GROUP }}" ]; then MISSING_SECRETS+=("AZURE_STATE_RESOURCE_GROUP"); fi
          if [ -z "${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" ]; then MISSING_SECRETS+=("AZURE_STATE_STORAGE_ACCOUNT"); fi
          if [ -z "${{ secrets.AZURE_STATE_CONTAINER }}" ]; then MISSING_SECRETS+=("AZURE_STATE_CONTAINER"); fi
          if [ -z "${{ secrets.AZURE_CLIENT_ID }}" ]; then MISSING_SECRETS+=("AZURE_CLIENT_ID"); fi
          if [ -z "${{ secrets.AZURE_CLIENT_SECRET }}" ]; then MISSING_SECRETS+=("AZURE_CLIENT_SECRET"); fi
          if [ -z "${{ secrets.AZURE_SUBSCRIPTION_ID }}" ]; then MISSING_SECRETS+=("AZURE_SUBSCRIPTION_ID"); fi
          if [ -z "${{ secrets.AZURE_TENANT_ID }}" ]; then MISSING_SECRETS+=("AZURE_TENANT_ID"); fi
          if [ -z "${{ secrets.RESOURCE_PREFIX }}" ]; then MISSING_SECRETS+=("RESOURCE_PREFIX"); fi
          if [ -z "${{ secrets.AZURE_LOCATION }}" ]; then MISSING_SECRETS+=("AZURE_LOCATION"); fi
          if [ -z "${{ secrets.CLUSTER_NAME_BASE }}" ]; then MISSING_SECRETS+=("CLUSTER_NAME_BASE"); fi
          
          # Validar secrets espec√≠ficos del ambiente
          if [ "${{ matrix.environment }}" = "dev" ]; then
            if [ -z "${{ secrets.AZURE_RESOURCE_GROUP_DEV }}" ]; then MISSING_SECRETS+=("AZURE_RESOURCE_GROUP_DEV"); fi
            if [ -z "${{ secrets.AKS_CLUSTER_NAME_DEV }}" ]; then MISSING_SECRETS+=("AKS_CLUSTER_NAME_DEV"); fi
          elif [ "${{ matrix.environment }}" = "stage" ]; then
            if [ -z "${{ secrets.AZURE_RESOURCE_GROUP_STAGE }}" ]; then MISSING_SECRETS+=("AZURE_RESOURCE_GROUP_STAGE"); fi
            if [ -z "${{ secrets.AKS_CLUSTER_NAME_STAGE }}" ]; then MISSING_SECRETS+=("AKS_CLUSTER_NAME_STAGE"); fi
          elif [ "${{ matrix.environment }}" = "prod" ]; then
            if [ -z "${{ secrets.AZURE_RESOURCE_GROUP_PROD }}" ]; then MISSING_SECRETS+=("AZURE_RESOURCE_GROUP_PROD"); fi
            if [ -z "${{ secrets.AKS_CLUSTER_NAME_PROD }}" ]; then MISSING_SECRETS+=("AKS_CLUSTER_NAME_PROD"); fi
          fi
          
          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "‚ùå Error: Missing required secrets:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            exit 1
          fi
          
          echo "‚úÖ All required secrets are configured"

      - name: Terraform Init
        if: steps.env_check.outputs.should_skip != 'true'
        id: init
        run: |
          echo "üîß Inicializando Terraform con backend remoto..."
          terraform init \
            -backend-config="resource_group_name=${{ secrets.AZURE_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ secrets.AZURE_STATE_CONTAINER }}" \
            -backend-config="key=${{ matrix.environment }}/terraform.tfstate" \
            -reconfigure
          echo "‚úÖ Terraform inicializado"
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Check State
        run: |
          if terraform state list 2>/dev/null | grep -q .; then
            echo "‚úÖ Estado encontrado con recursos existentes"
            terraform state list | head -20
          else
            echo "‚ÑπÔ∏è Estado vac√≠o o no existe (primera ejecuci√≥n)"
          fi
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        continue-on-error: true

      - name: Setup Azure CLI
        run: |
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
          az login --service-principal \
            -u "$ARM_CLIENT_ID" \
            -p "$ARM_CLIENT_SECRET" \
            --tenant "$ARM_TENANT_ID" \
            --output none
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Clean State (Remove Orphaned Resources)
        run: |
          echo "üßπ Limpiando recursos hu√©rfanos del estado de Terraform..."
          
          ORPHANED_RESOURCES=(
            "module.k8s_configmaps"
            "azurerm_resource_group.keyvault"
            "module.keyvault"
          )
          
          for resource in "${ORPHANED_RESOURCES[@]}"; do
            if terraform state list 2>/dev/null | grep -q "$resource"; then
              echo "‚ö†Ô∏è Encontrado $resource en el estado - eliminando..."
              terraform state list | grep "$resource" | while read res; do
                echo "Eliminando: $res"
                terraform state rm "$res" 2>&1 || echo "No se pudo eliminar $res"
              done
            fi
          done
          
          echo "‚úÖ Limpieza del estado completada"
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        continue-on-error: true

      - name: Terraform Plan
        if: steps.env_check.outputs.should_skip != 'true'
        id: plan
        run: |
          echo "üìã Iniciando Terraform Plan para ${{ matrix.environment }}..."
          rm -f tfplan plan_output.txt
          
          set +e
          terraform plan \
            -var-file=environments/${{ matrix.environment }}/terraform.tfvars \
            -var="resource_prefix=${{ secrets.RESOURCE_PREFIX }}" \
            -var="location=${{ secrets.AZURE_LOCATION }}" \
            -var="cluster_name=${{ secrets.CLUSTER_NAME_BASE }}" \
            -out=tfplan -detailed-exitcode 2>&1 | tee plan_output.txt
          PLAN_EXIT_CODE=${PIPESTATUS[0]}
          set -e
          
          echo "üìä C√≥digo de salida del plan: $PLAN_EXIT_CODE"
          
          # C√≥digo 0 = sin cambios, 1 = error, 2 = cambios detectados
          if [ "$PLAN_EXIT_CODE" = "1" ]; then
            echo "‚ùå Error durante la ejecuci√≥n del plan"
            cat plan_output.txt
            
            if [ -f tfplan ]; then
              echo "‚ö†Ô∏è Plan file existe pero con error - elimin√°ndolo"
              rm -f tfplan
            fi
            
            if grep -q "already exists" plan_output.txt; then
              echo "‚ö†Ô∏è Detectados recursos existentes que no est√°n en el estado"
              echo "üîÑ Intentando importar recursos existentes..."
              
              if [ "${{ matrix.environment }}" = "dev" ]; then
                RG_NAME="${{ secrets.AZURE_RESOURCE_GROUP_DEV }}"
              elif [ "${{ matrix.environment }}" = "stage" ]; then
                RG_NAME="${{ secrets.AZURE_RESOURCE_GROUP_STAGE }}"
              elif [ "${{ matrix.environment }}" = "prod" ]; then
                RG_NAME="${{ secrets.AZURE_RESOURCE_GROUP_PROD }}"
              fi
              
              if az group show --name "$RG_NAME" --query id -o tsv 2>/dev/null | grep -q .; then
                RG_ID="/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/$RG_NAME"
                echo "üì• Importando Resource Group: $RG_NAME"
                terraform import module.aks.azurerm_resource_group.main "$RG_ID" 2>&1 || echo "‚ö†Ô∏è Resource Group ya en estado o error al importar"
              fi
              
              echo "üîÑ Re-ejecutando plan despu√©s de importar..."
              rm -f tfplan plan_output.txt
              set +e
              terraform plan \
                -var-file=environments/${{ matrix.environment }}/terraform.tfvars \
                -var="resource_prefix=${{ secrets.RESOURCE_PREFIX }}" \
                -var="location=${{ secrets.AZURE_LOCATION }}" \
                -var="cluster_name=${{ secrets.CLUSTER_NAME_BASE }}" \
                -out=tfplan -detailed-exitcode 2>&1 | tee plan_output.txt
              PLAN_EXIT_CODE=${PIPESTATUS[0]}
              set -e
              
              echo "üìä C√≥digo de salida del plan (despu√©s de importar): $PLAN_EXIT_CODE"
              
              if [ "$PLAN_EXIT_CODE" = "1" ]; then
                echo "‚ùå Error: Plan fall√≥ despu√©s de importar"
                cat plan_output.txt
                if [ -f tfplan ]; then
                  rm -f tfplan
                fi
                exit 1
              fi
            else
              echo "‚ùå Error durante el plan (no relacionado con recursos existentes)"
              cat plan_output.txt
              exit 1
            fi
          fi
          
          # Validar que el plan se complet√≥ correctamente
          if [ "$PLAN_EXIT_CODE" = "2" ]; then
            echo "‚úÖ Plan generado exitosamente con cambios a aplicar"
            if [ ! -f tfplan ]; then
              echo "‚ùå ERROR CR√çTICO: Plan exitoso pero no se gener√≥ el archivo tfplan"
              exit 1
            fi
            echo "‚úÖ Archivo tfplan creado correctamente"
          elif [ "$PLAN_EXIT_CODE" = "0" ]; then
            echo "‚ÑπÔ∏è No hay cambios que aplicar"
            rm -f tfplan
          else
            echo "‚ùå ERROR: C√≥digo de salida inesperado del plan: $PLAN_EXIT_CODE"
            cat plan_output.txt
            exit 1
          fi
          
          echo "üìã Resumen del plan:"
          cat plan_output.txt | tail -20
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Terraform Apply
        if: steps.env_check.outputs.should_skip != 'true'
        run: |
          echo "üîç Verificando que el plan se ejecut√≥ correctamente..."
          
          if [ ! -f tfplan ]; then
            echo "‚ùå ERROR: No se encontr√≥ el archivo tfplan"
            echo "‚ö†Ô∏è El paso de Terraform Plan debe ejecutarse y generar un plan v√°lido antes de aplicar"
            echo "üìã Revisa los logs del paso 'Terraform Plan' para ver qu√© sali√≥ mal"
            exit 1
          fi
          
          echo "‚úÖ Archivo tfplan encontrado"
          echo "üöÄ Aplicando cambios de Terraform..."
          terraform apply -auto-approve tfplan
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Aplicaci√≥n completada exitosamente"
          else
            echo "‚ùå Error durante la aplicaci√≥n"
            exit 1
          fi
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Verify State Saved to Backend
        run: |
          echo "üîç Verificando que el estado se guard√≥ en Azure Storage..."
          STATE_KEY="${{ matrix.environment }}/terraform.tfstate"
          echo "üìç Ruta del estado: $STATE_KEY"
          
          # Verificar que el blob existe en el storage
          if az storage blob exists \
            --account-name "${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" \
            --container-name "${{ secrets.AZURE_STATE_CONTAINER }}" \
            --name "$STATE_KEY" \
            --auth-mode login \
            --query exists -o tsv 2>/dev/null | grep -q "true"; then
            echo "‚úÖ Estado verificado - se guard√≥ en Azure Storage: ${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}/${{ secrets.AZURE_STATE_CONTAINER }}/$STATE_KEY"
            
            # Obtener informaci√≥n del blob
            BLOB_INFO=$(az storage blob show \
              --account-name "${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" \
              --container-name "${{ secrets.AZURE_STATE_CONTAINER }}" \
              --name "$STATE_KEY" \
              --auth-mode login \
              --query "{size:properties.contentLength,lastModified:properties.lastModified}" -o json 2>/dev/null || echo "{}")
            
            if [ "$BLOB_INFO" != "{}" ]; then
              echo "üìä Informaci√≥n del estado:"
              echo "$BLOB_INFO" | jq -r '"Tama√±o: " + (.size | tostring) + " bytes, √öltima modificaci√≥n: " + .lastModified'
            fi
          else
            echo "‚ö†Ô∏è No se pudo verificar el blob en Azure Storage (puede ser normal si es la primera ejecuci√≥n)"
            echo "üìã Listando estados disponibles en el storage:"
            az storage blob list \
              --account-name "${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}" \
              --container-name "${{ secrets.AZURE_STATE_CONTAINER }}" \
              --auth-mode login \
              --query "[].name" -o tsv 2>/dev/null | head -10 || echo "No se pudieron listar los blobs"
          fi
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        continue-on-error: true

      - name: Terraform Output
        id: terraform_output
        run: |
          terraform output -json > terraform_output.json
          cat terraform_output.json
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Parse Terraform Outputs
        id: parse_outputs
        run: |
          RESOURCE_GROUP=$(jq -r '.resource_group_name.value // empty' terraform_output.json)
          CLUSTER_NAME=$(jq -r '.cluster_name.value // empty' terraform_output.json)
          
          if [ -z "$RESOURCE_GROUP" ] || [ "$RESOURCE_GROUP" = "null" ]; then
            echo "‚ùå Error: resource_group_name no encontrado en outputs"
            cat terraform_output.json
            exit 1
          fi
          
          if [ -z "$CLUSTER_NAME" ] || [ "$CLUSTER_NAME" = "null" ]; then
            echo "‚ùå Error: cluster_name no encontrado en outputs"
            cat terraform_output.json
            exit 1
          fi
          
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "Resource Group: $RESOURCE_GROUP"
          echo "Cluster Name: $CLUSTER_NAME"
          
          if az group show --name "$RESOURCE_GROUP" --query id -o tsv 2>/dev/null | grep -q .; then
            echo "‚úÖ Resource Group encontrado en Azure"
          else
            echo "‚ùå Error: Resource Group '$RESOURCE_GROUP' no existe en Azure"
            exit 1
          fi
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group "${{ steps.parse_outputs.outputs.resource_group }}" \
            --name "${{ steps.parse_outputs.outputs.cluster_name }}" \
            --overwrite-existing
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Create Spring ConfigMap in Kubernetes
        run: |
          echo "üì¶ Creando ConfigMap con variables de entorno para Spring Boot..."
          kubectl create configmap spring-env-config \
            --from-literal=SPRING_ZIPKIN_BASE_URL="http://zipkin:9411" \
            --from-literal=SPRING_CONFIG_IMPORT="http://cloud-config-service:9296" \
            --from-literal=EUREKA_CLIENT_SERVICEURL_DEFAULTZONE="http://service-discovery:8761/eureka" \
            --from-literal=SPRING_CLOUD_CONFIG_SERVER_GIT_URI="https://github.com/Ecommerce-Service-JDiaz/ecommerce-cloud-config-server" \
            --from-literal=SPRING_CLOUD_CONFIG_SERVER_GIT_DEFAULT_LABEL="main" \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "‚úÖ ConfigMap creado exitosamente"
        continue-on-error: true

      - name: Deployment Summary
        run: |
          echo "## ‚úÖ Infraestructura ${{ matrix.environment }} Desplegada" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Entorno:** ${{ matrix.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Resource Group:** ${{ steps.parse_outputs.outputs.resource_group }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster Name:** ${{ steps.parse_outputs.outputs.cluster_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Estado guardado en:** \`${{ secrets.AZURE_STATE_STORAGE_ACCOUNT }}/${{ secrets.AZURE_STATE_CONTAINER }}/${{ matrix.environment }}/terraform.tfstate\`" >> $GITHUB_STEP_SUMMARY
          echo "**Ejecutado por:** @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Fecha:** $(date)" >> $GITHUB_STEP_SUMMARY
